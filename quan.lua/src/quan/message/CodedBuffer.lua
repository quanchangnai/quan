---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by quanchangnai.
--- DateTime: 2019/9/1 15:27
---

require("quan.table")

local VarInt;
local unpack;
if _VERSION == "Lua 5.3" or _VERSION == "Lua 5.4" then
    VarInt = require("quan.message.VarInt53+")
    unpack = string.unpack
else
    VarInt = require("quan.message.VarInt52-")
    --https://web.tecgraf.puc-rio.br/~lhf/ftp/lua/#lpack
    require("pack")
    unpack = function(f, s, p)
        local next, result = string.unpack(s, f, p)
        return result
    end
end

local readVarInt = VarInt.readVarInt;
local writeVarInt = VarInt.writeVarInt;

---
---@class quan.message.CodedBuffer
---基于VarInt和ZigZag编码的字节缓冲区，字节顺序采用小端模式
---
local CodedBuffer = {
    ---类名
    class = "quan.message.CodedBuffer"
}

---构造CodedBuffer
---@param bytes 字节串，可以为空
function CodedBuffer.new(bytes)
    assert(bytes == nil or type(bytes) == "string", "参数[bytes]类型错误")
    local instance = {
        ---字节缓冲区
        bytes = bytes or "",
        ---下一个读的位置,该位置的数据还未读
        readIndex = 1,
        ---标记的读位置
        markedIndex = 1
    }
    setmetatable(instance, { __index = CodedBuffer })
    return instance
end

setmetatable(CodedBuffer, { __call = CodedBuffer.new })

function CodedBuffer:size()
    return self.bytes:len()
end

function CodedBuffer:mark()
    self.markedIndex = self.readIndex
end

function CodedBuffer:reset()
    self.readIndex = self.markedIndex
end

function CodedBuffer:clear()
    self.readIndex = 1
    self.bytes = ""
end

function CodedBuffer:readableCount()
    return self:size() - self.readIndex + 1;
end

function CodedBuffer:remainingBytes()
    local remainingBytes = self.bytes:sub(self.readIndex)
    self.readIndex = self.readIndex + remainingBytes:len()
    return remainingBytes
end

function CodedBuffer:discardReadBytes()
    self.bytes = self.bytes:sub(self.readIndex)
    self.readIndex = 1;
end

function CodedBuffer:readByte()
    local b = self.bytes:byte(self.readIndex)
    self.readIndex = self.readIndex + 1
    return b
end

function CodedBuffer:readBool()
    return self:readInt() ~= 0
end

function CodedBuffer:readShort()
    return readVarInt(self, 3)
end

function CodedBuffer:readInt()
    return readVarInt(self, 5)
end

function CodedBuffer:readLong()
    return readVarInt(self, 10)
end

function CodedBuffer:readFloat(scale)
    scale = scale or -1
    --assert(math.type(scale) == "integer", "参数[scale]类型错误")

    if scale < 0 then
        if self.readIndex + 3 > self:size() then
            error("读数据出错")
        end
        local n = unpack("<f", self.bytes, self.readIndex)
        self.readIndex = self.readIndex + 4
        return n
    else
        return self:readInt() / 10 ^ scale
    end
end

function CodedBuffer:readDouble(scale)
    scale = scale or -1
    --assert(math.type(scale) == "integer", "参数[scale]类型错误")

    if scale < 0 then
        if self.readIndex + 7 > self:size() then
            error("读数据出错")
        end
        local n = unpack("<d", self.bytes, self.readIndex)
        self.readIndex = self.readIndex + 8
        return n
    else
        return self:readInt() / 10 ^ scale
    end
end

function CodedBuffer:readBytes()
    local length = self:readInt()
    local readableCount = self:readableCount()
    if length > readableCount then
        error(string.format("读数据出错，希望读取%d字节,实际剩余%d字节", length, readableCount))
    end

    local bytes = self.bytes:sub(self.readIndex, self.readIndex + length - 1)
    self.readIndex = self.readIndex + length
    return bytes
end

function CodedBuffer:skipBytes()
    local length = self:readInt()
    local readableCount = self:readableCount()
    if length > readableCount then
        error(string.format("读数据出错，希望跳过%d字节,实际剩余%d字节", length, readableCount))
    end

    self.readIndex = self.readIndex + length
end

function CodedBuffer:readString()
    return self:readBytes()
end

function CodedBuffer:writeByte(b)
    self.bytes = self.bytes .. string.char(b)
end

function CodedBuffer:writeBool(b)
    assert(type(b) == "boolean", "参数[b]类型错误")
    self:writeInt(b and 1 or 0)
end

function CodedBuffer:writeShort(n)
    writeVarInt(self, n, 3)
end

function CodedBuffer:writeInt(n)
    writeVarInt(self, n, 5)
end

function CodedBuffer:writeLong(n)
    writeVarInt(self, n, 10)
end

function CodedBuffer:writeFloat(n, scale)
    scale = scale or -1
    assert(type(n) == "number", "参数[n]类型错误")
    --assert(math.type(scale) == "integer", "参数[scale]类型错误")

    if scale < 0 then
        self.bytes = self.bytes .. string.pack("<f", n)
    else
        self:writeFixed(n, scale)
    end
end

function CodedBuffer:writeDouble(n, scale)
    scale = scale or -1
    assert(type(n) == "number", "参数[n]类型错误")
    --assert(math.type(scale) == "integer", "参数[scale]类型错误")

    if scale < 0 then
        self.bytes = self.bytes .. string.pack("<d", n)
    else
        self:writeFixed(n, scale)
    end
end

function CodedBuffer:writeFixed(n, scale)
    local times = 10 ^ scale
    local minValue = -0x80000000 * times;
    local maxValue = 0x7FFFFFFF * times;

    if n < minValue or n > maxValue then
        local format = "参数[%s]超出了限定范围[%s,%s],无法转换为指定精度[%s]的定点型数据";
        error(string.format(format, n, minValue, maxValue, scale))
    else
        self:writeInt(math.floor(n * times))
    end
end

function CodedBuffer:writeBytes(bytes)
    assert(type(bytes) == "string", "参数[bytes]类型错误")
    self:writeInt(string.len(bytes))
    self.bytes = self.bytes .. bytes
end

function CodedBuffer:writeBuffer(buffer)
    self:writeBytes(buffer:remainingBytes());
end

function CodedBuffer:writeString(s)
    self:writeBytes(s)
end

CodedBuffer = table.readOnly(CodedBuffer)
return CodedBuffer