---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by quanchangnai.
--- DateTime: 2019/9/1 15:27
---

require("quan.table")

local VarInt;
local unpack;
if _VERSION == "Lua 5.3" or _VERSION == "Lua 5.4" then
    VarInt = require("quan.message.VarInt64")
    unpack = string.unpack
else
    VarInt = require("quan.message.VarInt32")
    --https://web.tecgraf.puc-rio.br/~lhf/ftp/lua/#lpack
    require("pack")
    unpack = function(f, s, p)
        local next, result = string.unpack(s, f, p)
        return result
    end
end

local readVarInt = VarInt.readVarInt;
local writeVarInt = VarInt.writeVarInt;

---
---@class quan.message.Buffer
---基于VarInt和ZigZag编码的字节缓冲区，字节顺序采用小端模式
---
local Buffer = {
    ---类名
    class = "quan.message.Buffer"
}

---构造Buffer
---@param bytes 字节串，可以为空
function Buffer.new(bytes)
    assert(bytes == nil or type(bytes) == "string", "参数[bytes]类型错误")
    local instance = {
        ---字节缓冲区
        bytes = bytes or "",
        ---下一个读的位置,该位置的数据还未读
        readIndex = 1,
        ---标记的读位置
        markedIndex = 1
    }
    setmetatable(instance, { __index = Buffer })
    return instance
end

function Buffer:size()
    return self.bytes:len()
end

function Buffer:mark()
    self.markedIndex = self.readIndex
end

function Buffer:reset()
    self.readIndex = self.markedIndex
end

function Buffer:clear()
    self.readIndex = 1
    self.bytes = ""
end

function Buffer:readableCount()
    return self:size() - self.readIndex + 1;
end

function Buffer:remainingBytes()
    local remainingBytes = self.bytes:sub(self.readIndex)
    self.readIndex = self.readIndex + remainingBytes:len()
    return remainingBytes
end

function Buffer:discardReadBytes()
    self.bytes = self.bytes:sub(self.readIndex)
    self.readIndex = 1;
end

function Buffer:readByte()
    local b = self.bytes:byte(self.readIndex)
    self.readIndex = self.readIndex + 1
    return b
end

function Buffer:readBool()
    return self:readInt() ~= 0
end

function Buffer:readShort()
    return readVarInt(self, 3)
end

function Buffer:readInt()
    return readVarInt(self, 5)
end

function Buffer:readLong()
    return readVarInt(self, 10)
end

function Buffer:readFloat(scale)
    scale = scale or -1
    --assert(math.type(scale) == "integer", "参数[scale]类型错误")

    if scale < 0 then
        if self.readIndex + 3 > self:size() then
            error("读数据出错")
        end
        local n = unpack("<f", self.bytes, self.readIndex)
        self.readIndex = self.readIndex + 4
        return n
    else
        return self:readLong() / 10 ^ scale
    end

end

function Buffer:readDouble(scale)
    scale = scale or -1
    --assert(math.type(scale) == "integer", "参数[scale]类型错误")

    if scale < 0 then
        if self.readIndex + 7 > self:size() then
            error("读数据出错")
        end
        local n = unpack("<d", self.bytes, self.readIndex)
        self.readIndex = self.readIndex + 8
        return n
    else
        return self:readLong() / 10 ^ scale
    end

end

function Buffer:readBytes()
    local length = self:readInt()
    local readableCount = self:readableCount()
    if length > readableCount then
        error(string.format("读数据出错，希望读取%d字节,实际剩余%d字节", length, readableCount))
    end

    local bytes = self.bytes:sub(self.readIndex, self.readIndex + length - 1)
    self.readIndex = self.readIndex + length
    return bytes
end

function Buffer:skipBytes()
    local length = self:readInt()
    local readableCount = self:readableCount()
    if length > readableCount then
        error(string.format("读数据出错，希望跳过%d字节,实际剩余%d字节", length, readableCount))
    end

    self.readIndex = self.readIndex + length
end

function Buffer:readString()
    return self:readBytes()
end

function Buffer:writeByte(b)
    self.bytes = self.bytes .. string.char(b)
end

function Buffer:writeBool(b)
    assert(type(b) == "boolean", "参数[b]类型错误")
    self:writeInt(b and 1 or 0)
end

function Buffer:writeShort(n)
    writeVarInt(self, n, 3)
end

function Buffer:writeInt(n)
    writeVarInt(self, n, 5)
end

function Buffer:writeLong(n)
    writeVarInt(self, n, 10)
end

function Buffer:writeFloat(n, scale)
    scale = scale or -1
    assert(type(n) == "number", "参数[n]类型错误")
    --assert(math.type(scale) == "integer", "参数[scale]类型错误")

    if scale < 0 then
        self.bytes = self.bytes .. string.pack("<f", n)
    else
        self:writeDouble(n, scale)
    end
end

function Buffer:writeDouble(n, scale)
    scale = scale or -1
    assert(type(n) == "number", "参数[n]类型错误")
    --assert(math.type(scale) == "integer", "参数[scale]类型错误")

    if scale < 0 then
        self.bytes = self.bytes .. string.pack("<d", n)
        return
    end

    local times = 10 ^ scale
    local threshold = 0x7FFFFFFFFFFFFFFF / times;
    if n < -threshold or n > threshold then
        error(string.format("参数[%s]超出了限定范围[%s,%s],无法转换为指定精度[%s]的定点型数据", n, -threshold, threshold, scale))
    else
        self:writeLong(math.floor(n * times))
    end
end

function Buffer:writeBytes(bytes)
    assert(type(bytes) == "string", "参数[bytes]类型错误")
    self:writeInt(bytes:len())
    self.bytes = self.bytes .. bytes
end

function Buffer:writeBuffer(buffer)
    self:writeBytes(buffer:remainingBytes());
end

function Buffer:writeString(s)
    self:writeBytes(s)
end

function Buffer:writeTag(tag)
    assert(tag >= 0 and tag <= 255, "参数[tag]超出限定范围0-255")
    self:writeByte(tag)
end

function Buffer:readTag()
    return self:readByte()
end

Buffer = table.readOnly(Buffer)
return Buffer